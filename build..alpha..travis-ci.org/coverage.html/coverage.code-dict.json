{"/home/travis/build/npmtest/node-npmtest-babel-eslint/test.js":"/* istanbul instrument in package npmtest_babel_eslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-babel-eslint/lib.npmtest_babel_eslint.js":"/* istanbul instrument in package npmtest_babel_eslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_babel_eslint = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_babel_eslint = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-babel-eslint/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-babel-eslint && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_babel_eslint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_babel_eslint\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_babel_eslint.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_babel_eslint.rollup.js'] =\n            local.assetsDict['/assets.npmtest_babel_eslint.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_babel_eslint.__dirname + '/lib.npmtest_babel_eslint.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-babel-eslint/node_modules/babel-eslint/index.js":"var babylonToEspree = require(\"./babylon-to-espree\");\nvar Module          = require(\"module\");\nvar path            = require(\"path\");\nvar parse           = require(\"babylon\").parse;\nvar t               = require(\"babel-types\");\nvar tt              = require(\"babylon\").tokTypes;\nvar traverse        = require(\"babel-traverse\").default;\nvar codeFrame       = require(\"babel-code-frame\");\n\nvar hasPatched = false;\nvar eslintOptions = {};\n\nfunction getModules() {\n  try {\n    // avoid importing a local copy of eslint, try to find a peer dependency\n    var eslintLoc = Module._resolveFilename(\"eslint\", module.parent);\n  } catch (err) {\n    try {\n      // avoids breaking in jest where module.parent is undefined\n      eslintLoc = require.resolve(\"eslint\");\n    } catch (err) {\n      throw new ReferenceError(\"couldn't resolve eslint\");\n    }\n  }\n\n  // get modules relative to what eslint will load\n  var eslintMod = new Module(eslintLoc);\n  eslintMod.filename = eslintLoc;\n  eslintMod.paths = Module._nodeModulePaths(path.dirname(eslintLoc));\n\n  try {\n    var escope = eslintMod.require(\"eslint-scope\");\n    var Definition = eslintMod.require(\"eslint-scope/lib/definition\").Definition;\n    var referencer = eslintMod.require(\"eslint-scope/lib/referencer\");\n  } catch (err) {\n    escope  = eslintMod.require(\"escope\");\n    Definition = eslintMod.require(\"escope/lib/definition\").Definition;\n    referencer = eslintMod.require(\"escope/lib/referencer\");\n  }\n\n  var estraverse = eslintMod.require(\"estraverse\");\n\n  if (referencer.__esModule) referencer = referencer.default;\n\n  return {\n    Definition,\n    escope,\n    estraverse,\n    referencer,\n  };\n}\n\nfunction monkeypatch(modules) {\n  var Definition = modules.Definition;\n  var escope = modules.escope;\n  var estraverse = modules.estraverse;\n  var referencer = modules.referencer;\n\n  Object.assign(estraverse.VisitorKeys, t.VISITOR_KEYS);\n  estraverse.VisitorKeys.MethodDefinition.push(\"decorators\");\n  estraverse.VisitorKeys.Property.push(\"decorators\");\n\n  var analyze = escope.analyze;\n  escope.analyze = function (ast, opts) {\n    opts.ecmaVersion = eslintOptions.ecmaVersion;\n    opts.sourceType = eslintOptions.sourceType;\n    if (eslintOptions.globalReturn !== undefined) {\n      opts.nodejsScope = eslintOptions.globalReturn;\n    }\n\n    var results = analyze.call(this, ast, opts);\n    return results;\n  };\n\n  // if there are decorators, then visit each\n  function visitDecorators(node) {\n    if (!node.decorators) {\n      return;\n    }\n    for (var i = 0; i < node.decorators.length; i++) {\n      if (node.decorators[i].expression) {\n        this.visit(node.decorators[i]);\n      }\n    }\n  }\n\n  // iterate through part of t.VISITOR_KEYS\n  var flowFlippedAliasKeys = t.FLIPPED_ALIAS_KEYS.Flow.concat([\n    \"ArrayPattern\",\n    \"ClassDeclaration\",\n    \"ClassExpression\",\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"Identifier\",\n    \"ObjectPattern\",\n    \"RestElement\"\n  ]);\n  var visitorKeysMap = Object.keys(t.VISITOR_KEYS).reduce(function(acc, key) {\n    var value = t.VISITOR_KEYS[key];\n    if (flowFlippedAliasKeys.indexOf(value) === -1) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n\n  var propertyTypes = {\n    // loops\n    callProperties: { type: \"loop\", values: [\"value\"] },\n    indexers: { type: \"loop\", values: [\"key\", \"value\"] },\n    properties: { type: \"loop\", values: [\"argument\", \"value\"] },\n    types: { type: \"loop\" },\n    params: { type: \"loop\" },\n    // single property\n    argument: { type: \"single\" },\n    elementType: { type: \"single\" },\n    qualification: { type: \"single\" },\n    rest: { type: \"single\" },\n    returnType: { type: \"single\" },\n    // others\n    typeAnnotation: { type: \"typeAnnotation\" },\n    typeParameters: { type: \"typeParameters\" },\n    id: { type: \"id\" }\n  };\n\n  function visitTypeAnnotation(node) {\n    // get property to check (params, id, etc...)\n    var visitorValues = visitorKeysMap[node.type];\n    if (!visitorValues) {\n      return;\n    }\n\n    // can have multiple properties\n    for (var i = 0; i < visitorValues.length; i++) {\n      var visitorValue = visitorValues[i];\n      var propertyType = propertyTypes[visitorValue];\n      var nodeProperty = node[visitorValue];\n      // check if property or type is defined\n      if (propertyType == null || nodeProperty == null) {\n        continue;\n      }\n      if (propertyType.type === \"loop\") {\n        for (var j = 0; j < nodeProperty.length; j++) {\n          if (Array.isArray(propertyType.values)) {\n            for (var k = 0; k < propertyType.values.length; k++) {\n              var loopPropertyNode = nodeProperty[j][propertyType.values[k]];\n              if (loopPropertyNode) {\n                checkIdentifierOrVisit.call(this, loopPropertyNode);\n              }\n            }\n          } else {\n            checkIdentifierOrVisit.call(this, nodeProperty[j]);\n          }\n        }\n      } else if (propertyType.type === \"single\") {\n        checkIdentifierOrVisit.call(this, nodeProperty);\n      } else if (propertyType.type === \"typeAnnotation\") {\n        visitTypeAnnotation.call(this, node.typeAnnotation);\n      } else if (propertyType.type === \"typeParameters\") {\n        for (var l = 0; l < node.typeParameters.params.length; l++) {\n          checkIdentifierOrVisit.call(this, node.typeParameters.params[l]);\n        }\n      } else if (propertyType.type === \"id\") {\n        if (node.id.type === \"Identifier\") {\n          checkIdentifierOrVisit.call(this, node.id);\n        } else {\n          visitTypeAnnotation.call(this, node.id);\n        }\n      }\n    }\n  }\n\n  function checkIdentifierOrVisit(node) {\n    if (node.typeAnnotation) {\n      visitTypeAnnotation.call(this, node.typeAnnotation);\n    } else if (node.type === \"Identifier\") {\n      this.visit(node);\n    } else {\n      visitTypeAnnotation.call(this, node);\n    }\n  }\n\n  function nestTypeParamScope(manager, node) {\n    var parentScope = manager.__currentScope;\n    var scope = new escope.Scope(manager, \"type-parameters\", parentScope, node, false);\n    manager.__nestScope(scope);\n    for (var j = 0; j < node.typeParameters.params.length; j++) {\n      var name = node.typeParameters.params[j];\n      scope.__define(name, new Definition(\"TypeParameter\", name, name));\n      if (name.typeAnnotation) {\n        checkIdentifierOrVisit.call(this, name);\n      }\n    }\n    scope.__define = function() {\n      return parentScope.__define.apply(parentScope, arguments);\n    };\n    return scope;\n  }\n\n  // visit decorators that are in: ClassDeclaration / ClassExpression\n  var visitClass = referencer.prototype.visitClass;\n  referencer.prototype.visitClass = function(node) {\n    visitDecorators.call(this, node);\n    var typeParamScope;\n    if (node.typeParameters) {\n      typeParamScope = nestTypeParamScope.call(this, this.scopeManager, node);\n    }\n    // visit flow type: ClassImplements\n    if (node.implements) {\n      for (var i = 0; i < node.implements.length; i++) {\n        checkIdentifierOrVisit.call(this, node.implements[i]);\n      }\n    }\n    if (node.superTypeParameters) {\n      for (var k = 0; k < node.superTypeParameters.params.length; k++) {\n        checkIdentifierOrVisit.call(this, node.superTypeParameters.params[k]);\n      }\n    }\n    visitClass.call(this, node);\n    if (typeParamScope) {\n      this.close(node);\n    }\n  };\n\n  // visit decorators that are in: Property / MethodDefinition\n  var visitProperty = referencer.prototype.visitProperty;\n  referencer.prototype.visitProperty = function(node) {\n    if (node.value && node.value.type === \"TypeCastExpression\") {\n      visitTypeAnnotation.call(this, node.value);\n    }\n    visitDecorators.call(this, node);\n    visitProperty.call(this, node);\n  };\n\n  // visit ClassProperty as a Property.\n  referencer.prototype.ClassProperty = function(node) {\n    if (node.typeAnnotation) {\n      visitTypeAnnotation.call(this, node.typeAnnotation);\n    }\n    this.visitProperty(node);\n  };\n\n  // visit flow type in FunctionDeclaration, FunctionExpression, ArrowFunctionExpression\n  var visitFunction = referencer.prototype.visitFunction;\n  referencer.prototype.visitFunction = function(node) {\n    var typeParamScope;\n    if (node.typeParameters) {\n      typeParamScope = nestTypeParamScope.call(this, this.scopeManager, node);\n    }\n    if (node.returnType) {\n      checkIdentifierOrVisit.call(this, node.returnType);\n    }\n    // only visit if function parameters have types\n    if (node.params) {\n      for (var i = 0; i < node.params.length; i++) {\n        var param = node.params[i];\n        if (param.typeAnnotation) {\n          checkIdentifierOrVisit.call(this, param);\n        } else if (t.isAssignmentPattern(param)) {\n          if (param.left.typeAnnotation) {\n            checkIdentifierOrVisit.call(this, param.left);\n          }\n        }\n      }\n    }\n    // set ArrayPattern/ObjectPattern visitor keys back to their original. otherwise\n    // escope will traverse into them and include the identifiers within as declarations\n    estraverse.VisitorKeys.ObjectPattern = [\"properties\"];\n    estraverse.VisitorKeys.ArrayPattern = [\"elements\"];\n    visitFunction.call(this, node);\n    // set them back to normal...\n    estraverse.VisitorKeys.ObjectPattern = t.VISITOR_KEYS.ObjectPattern;\n    estraverse.VisitorKeys.ArrayPattern = t.VISITOR_KEYS.ArrayPattern;\n    if (typeParamScope) {\n      this.close(node);\n    }\n  };\n\n  // visit flow type in VariableDeclaration\n  var variableDeclaration = referencer.prototype.VariableDeclaration;\n  referencer.prototype.VariableDeclaration = function(node) {\n    if (node.declarations) {\n      for (var i = 0; i < node.declarations.length; i++) {\n        var id = node.declarations[i].id;\n        var typeAnnotation = id.typeAnnotation;\n        if (typeAnnotation) {\n          checkIdentifierOrVisit.call(this, typeAnnotation);\n        }\n      }\n    }\n    variableDeclaration.call(this, node);\n  };\n\n  function createScopeVariable (node, name) {\n    this.currentScope().variableScope.__define(name,\n      new Definition(\n        \"Variable\",\n        name,\n        node,\n        null,\n        null,\n        null\n      )\n    );\n  }\n\n  referencer.prototype.InterfaceDeclaration = function(node) {\n    createScopeVariable.call(this, node, node.id);\n    var typeParamScope;\n    if (node.typeParameters) {\n      typeParamScope = nestTypeParamScope.call(this, this.scopeManager, node);\n    }\n    // TODO: Handle mixins\n    for (var i = 0; i < node.extends.length; i++) {\n      visitTypeAnnotation.call(this, node.extends[i]);\n    }\n    visitTypeAnnotation.call(this, node.body);\n    if (typeParamScope) {\n      this.close(node);\n    }\n  };\n\n  referencer.prototype.TypeAlias = function(node) {\n    createScopeVariable.call(this, node, node.id);\n    var typeParamScope;\n    if (node.typeParameters) {\n      typeParamScope = nestTypeParamScope.call(this, this.scopeManager, node);\n    }\n    if (node.right) {\n      visitTypeAnnotation.call(this, node.right);\n    }\n    if (typeParamScope) {\n      this.close(node);\n    }\n  };\n\n  referencer.prototype.DeclareModule =\n  referencer.prototype.DeclareFunction =\n  referencer.prototype.DeclareVariable =\n  referencer.prototype.DeclareClass = function(node) {\n    if (node.id) {\n      createScopeVariable.call(this, node, node.id);\n    }\n\n    var typeParamScope;\n    if (node.typeParameters) {\n      typeParamScope = nestTypeParamScope.call(this, this.scopeManager, node);\n    }\n    if (typeParamScope) {\n      this.close(node);\n    }\n  };\n}\n\nexports.parse = function (code, options) {\n  options = options || {};\n  eslintOptions.ecmaVersion = options.ecmaVersion = options.ecmaVersion || 6;\n  eslintOptions.sourceType = options.sourceType = options.sourceType || \"module\";\n  eslintOptions.allowImportExportEverywhere = options.allowImportExportEverywhere = options.allowImportExportEverywhere || false;\n  if (options.sourceType === \"module\") {\n    eslintOptions.globalReturn = false;\n  } else {\n    delete eslintOptions.globalReturn;\n  }\n\n  if (!hasPatched) {\n    hasPatched = true;\n    try {\n      monkeypatch(getModules());\n    } catch (err) {\n      console.error(err.stack);\n      process.exit(1);\n    }\n  }\n\n  return exports.parseNoPatch(code, options);\n};\n\nexports.parseNoPatch = function (code, options) {\n  var opts = {\n    codeFrame: options.hasOwnProperty(\"codeFrame\") ? options.codeFrame : true,\n    sourceType: options.sourceType,\n    allowImportExportEverywhere: options.allowImportExportEverywhere, // consistent with espree\n    allowReturnOutsideFunction: true,\n    allowSuperOutsideMethod: true,\n    plugins: [\n      \"flow\",\n      \"jsx\",\n      \"asyncFunctions\",\n      \"asyncGenerators\",\n      \"classConstructorCall\",\n      \"classProperties\",\n      \"decorators\",\n      \"doExpressions\",\n      \"exponentiationOperator\",\n      \"exportExtensions\",\n      \"functionBind\",\n      \"functionSent\",\n      \"objectRestSpread\",\n      \"trailingFunctionCommas\",\n      \"dynamicImport\"\n    ]\n  };\n\n  var ast;\n  try {\n    ast = parse(code, opts);\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n\n      err.lineNumber = err.loc.line;\n      err.column = err.loc.column;\n\n      if (opts.codeFrame) {\n        err.lineNumber = err.loc.line;\n        err.column = err.loc.column + 1;\n\n        // remove trailing \"(LINE:COLUMN)\" acorn message and add in esprima syntax error message start\n        err.message = \"Line \" + err.lineNumber + \": \" + err.message.replace(/ \\((\\d+):(\\d+)\\)$/, \"\") +\n        // add codeframe\n        \"\\n\\n\" +\n        codeFrame(code, err.lineNumber, err.column, { highlightCode: true });\n      }\n    }\n\n    throw err;\n  }\n\n  babylonToEspree(ast, traverse, tt, code);\n\n  return ast;\n};\n","/home/travis/build/npmtest/node-npmtest-babel-eslint/node_modules/babel-eslint/babylon-to-espree/index.js":"\"use strict\";\n\nvar attachComments  = require(\"./attachComments\");\nvar convertComments = require(\"./convertComments\");\nvar toTokens        = require(\"./toTokens\");\nvar toAST           = require(\"./toAST\");\n\nmodule.exports = function (ast, traverse, tt, code) {\n  // remove EOF token, eslint doesn't use this for anything and it interferes\n  // with some rules see https://github.com/babel/babel-eslint/issues/2\n  // todo: find a more elegant way to do this\n  ast.tokens.pop();\n\n  // convert tokens\n  ast.tokens = toTokens(ast.tokens, tt, code);\n\n  // add comments\n  convertComments(ast.comments);\n\n  // transform esprima and acorn divergent nodes\n  toAST(ast, traverse, code);\n\n  // ast.program.tokens = ast.tokens;\n  // ast.program.comments = ast.comments;\n  // ast = ast.program;\n\n  // remove File\n  ast.type = \"Program\";\n  ast.sourceType = ast.program.sourceType;\n  ast.directives = ast.program.directives;\n  ast.body = ast.program.body;\n  delete ast.program;\n  delete ast._paths;\n\n  attachComments(ast, ast.comments, ast.tokens);\n};\n","/home/travis/build/npmtest/node-npmtest-babel-eslint/node_modules/babel-eslint/babylon-to-espree/attachComments.js":"\"use strict\";\n\n// comment fixes\nmodule.exports = function (ast, comments, tokens) {\n  if (comments.length) {\n    var firstComment = comments[0];\n    var lastComment = comments[comments.length - 1];\n    // fixup program start\n    if (!tokens.length) {\n      // if no tokens, the program starts at the end of the last comment\n      ast.start = lastComment.end;\n      ast.loc.start.line = lastComment.loc.end.line;\n      ast.loc.start.column = lastComment.loc.end.column;\n\n      if (ast.leadingComments === null && ast.innerComments.length) {\n        ast.leadingComments = ast.innerComments;\n      }\n    } else if (firstComment.start < tokens[0].start) {\n      // if there are comments before the first token, the program starts at the first token\n      var token = tokens[0];\n      // ast.start = token.start;\n      // ast.loc.start.line = token.loc.start.line;\n      // ast.loc.start.column = token.loc.start.column;\n\n      // estraverse do not put leading comments on first node when the comment\n      // appear before the first token\n      if (ast.body.length) {\n        var node = ast.body[0];\n        node.leadingComments = [];\n        var firstTokenStart = token.start;\n        var len = comments.length;\n        for (var i = 0; i < len && comments[i].start < firstTokenStart; i++) {\n          node.leadingComments.push(comments[i]);\n        }\n      }\n    }\n    // fixup program end\n    if (tokens.length) {\n      var lastToken = tokens[tokens.length - 1];\n      if (lastComment.end > lastToken.end) {\n        // If there is a comment after the last token, the program ends at the\n        // last token and not the comment\n        // ast.end = lastToken.end;\n        ast.range[1] = lastToken.end;\n        ast.loc.end.line = lastToken.loc.end.line;\n        ast.loc.end.column = lastToken.loc.end.column;\n      }\n    }\n  } else {\n    if (!tokens.length) {\n      ast.loc.start.line = 1;\n      ast.loc.end.line = 1;\n    }\n  }\n  if (ast.body && ast.body.length > 0) {\n    ast.loc.start.line = ast.body[0].loc.start.line;\n    ast.range[0] = ast.body[0].start;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-babel-eslint/node_modules/babel-eslint/babylon-to-espree/convertComments.js":"\"use strict\";\n\nmodule.exports = function (comments) {\n  for (var i = 0; i < comments.length; i++) {\n    var comment = comments[i];\n    if (comment.type === \"CommentBlock\") {\n      comment.type = \"Block\";\n    } else if (comment.type === \"CommentLine\") {\n      comment.type = \"Line\";\n    }\n    // sometimes comments don't get ranges computed,\n    // even with options.ranges === true\n    if (!comment.range) {\n      comment.range = [comment.start, comment.end];\n    }\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-babel-eslint/node_modules/babel-eslint/babylon-to-espree/toTokens.js":"\"use strict\";\n\nvar convertTemplateType = require(\"./convertTemplateType\");\nvar toToken = require(\"./toToken\");\n\nmodule.exports = function (tokens, tt, code) {\n  // transform tokens to type \"Template\"\n  convertTemplateType(tokens, tt);\n\n  var transformedTokens = [];\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i];\n    if (token.type !== \"CommentLine\" && token.type !== \"CommentBlock\") {\n      transformedTokens.push(toToken(token, tt, code));\n    }\n  }\n\n  return transformedTokens;\n};\n","/home/travis/build/npmtest/node-npmtest-babel-eslint/node_modules/babel-eslint/babylon-to-espree/convertTemplateType.js":"\"use strict\";\n\nmodule.exports = function (tokens, tt) {\n  var startingToken    = 0;\n  var currentToken     = 0;\n  var numBraces        = 0; // track use of {}\n  var numBackQuotes    = 0; // track number of nested templates\n\n  function isBackQuote(token) {\n    return tokens[token].type === tt.backQuote;\n  }\n\n  function isTemplateStarter(token) {\n    return isBackQuote(token) ||\n           // only can be a template starter when in a template already\n           tokens[token].type === tt.braceR && numBackQuotes > 0;\n  }\n\n  function isTemplateEnder(token) {\n    return isBackQuote(token) ||\n           tokens[token].type === tt.dollarBraceL;\n  }\n\n  // append the values between start and end\n  function createTemplateValue(start, end) {\n    var value = \"\";\n    while (start <= end) {\n      if (tokens[start].value) {\n        value += tokens[start].value;\n      } else if (tokens[start].type !== tt.template) {\n        value += tokens[start].type.label;\n      }\n      start++;\n    }\n    return value;\n  }\n\n  // create Template token\n  function replaceWithTemplateType(start, end) {\n    var templateToken = {\n      type: \"Template\",\n      value: createTemplateValue(start, end),\n      start: tokens[start].start,\n      end: tokens[end].end,\n      loc: {\n        start: tokens[start].loc.start,\n        end: tokens[end].loc.end\n      }\n    };\n\n    // put new token in place of old tokens\n    tokens.splice(start, end - start + 1, templateToken);\n  }\n\n  function trackNumBraces(token) {\n    if (tokens[token].type === tt.braceL) {\n      numBraces++;\n    } else if (tokens[token].type === tt.braceR) {\n      numBraces--;\n    }\n  }\n\n  while (startingToken < tokens.length) {\n    // template start: check if ` or }\n    if (isTemplateStarter(startingToken) && numBraces === 0) {\n      if (isBackQuote(startingToken)) {\n        numBackQuotes++;\n      }\n\n      currentToken = startingToken + 1;\n\n      // check if token after template start is \"template\"\n      if (currentToken >= tokens.length - 1 || tokens[currentToken].type !== tt.template) {\n        break;\n      }\n\n      // template end: find ` or ${\n      while (!isTemplateEnder(currentToken)) {\n        if (currentToken >= tokens.length - 1) {\n          break;\n        }\n        currentToken++;\n      }\n\n      if (isBackQuote(currentToken)) {\n        numBackQuotes--;\n      }\n      // template start and end found: create new token\n      replaceWithTemplateType(startingToken, currentToken);\n    } else if (numBackQuotes > 0) {\n      trackNumBraces(startingToken);\n    }\n    startingToken++;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-babel-eslint/node_modules/babel-eslint/babylon-to-espree/toToken.js":"\"use strict\";\n\nmodule.exports = function (token, tt, source) {\n  var type = token.type;\n  token.range = [token.start, token.end];\n\n  if (type === tt.name) {\n    token.type = \"Identifier\";\n  } else if (type === tt.semi || type === tt.comma ||\n             type === tt.parenL || type === tt.parenR ||\n             type === tt.braceL || type === tt.braceR ||\n             type === tt.slash || type === tt.dot ||\n             type === tt.bracketL || type === tt.bracketR ||\n             type === tt.ellipsis || type === tt.arrow ||\n             type === tt.star || type === tt.incDec ||\n             type === tt.colon || type === tt.question ||\n             type === tt.template || type === tt.backQuote ||\n             type === tt.dollarBraceL || type === tt.at ||\n             type === tt.logicalOR || type === tt.logicalAND ||\n             type === tt.bitwiseOR || type === tt.bitwiseXOR ||\n             type === tt.bitwiseAND || type === tt.equality ||\n             type === tt.relational || type === tt.bitShift ||\n             type === tt.plusMin || type === tt.modulo ||\n             type === tt.exponent || type === tt.prefix ||\n             type === tt.doubleColon ||\n             type.isAssign) {\n    token.type = \"Punctuator\";\n    if (!token.value) token.value = type.label;\n  } else if (type === tt.jsxTagStart) {\n    token.type = \"Punctuator\";\n    token.value = \"<\";\n  } else if (type === tt.jsxTagEnd) {\n    token.type = \"Punctuator\";\n    token.value = \">\";\n  } else if (type === tt.jsxName) {\n    token.type = \"JSXIdentifier\";\n  } else if (type === tt.jsxText) {\n    token.type = \"JSXText\";\n  } else if (type.keyword === \"null\") {\n    token.type = \"Null\";\n  } else if (type.keyword === \"false\" || type.keyword === \"true\") {\n    token.type = \"Boolean\";\n  } else if (type.keyword) {\n    token.type = \"Keyword\";\n  } else if (type === tt.num) {\n    token.type = \"Numeric\";\n    token.value = source.slice(token.start, token.end);\n  } else if (type === tt.string) {\n    token.type = \"String\";\n    token.value = source.slice(token.start, token.end);\n  } else if (type === tt.regexp) {\n    token.type = \"RegularExpression\";\n    var value = token.value;\n    token.regex = {\n      pattern: value.pattern,\n      flags: value.flags\n    };\n    token.value = `/${value.pattern}/${value.flags}`;\n  }\n\n  return token;\n};\n","/home/travis/build/npmtest/node-npmtest-babel-eslint/node_modules/babel-eslint/babylon-to-espree/toAST.js":"\"use strict\";\n\nvar convertComments = require(\"./convertComments\");\n\nmodule.exports = function (ast, traverse, code) {\n  var state = { source: code };\n  ast.range = [ast.start, ast.end];\n  traverse(ast, astTransformVisitor, null, state);\n};\n\nfunction changeToLiteral(node, state) {\n  node.type = \"Literal\";\n  if (!node.raw) {\n    if (node.extra && node.extra.raw) {\n      node.raw = node.extra.raw;\n    } else {\n      node.raw = state.source.slice(node.start, node.end);\n    }\n  }\n}\n\nvar astTransformVisitor = {\n  noScope: true,\n  enter (path) {\n    var node = path.node;\n\n    node.range = [node.start, node.end];\n\n    // private var to track original node type\n    node._babelType = node.type;\n\n    if (node.innerComments) {\n      node.trailingComments = node.innerComments;\n      delete node.innerComments;\n    }\n\n    if (node.trailingComments) {\n      convertComments(node.trailingComments);\n    }\n\n    if (node.leadingComments) {\n      convertComments(node.leadingComments);\n    }\n\n    // make '_paths' non-enumerable (babel-eslint #200)\n    Object.defineProperty(node, \"_paths\", { value: node._paths, writable: true });\n  },\n  exit (path, state) {\n    var node = path.node;\n\n    // fixDirectives\n    if (path.isFunction() || path.isProgram()) {\n      var directivesContainer = node;\n      var body = node.body;\n      if (node.type !== \"Program\") {\n        directivesContainer = body;\n        body = body.body;\n      }\n      if (directivesContainer.directives) {\n        for (var i = directivesContainer.directives.length - 1; i >= 0; i--) {\n          var directive = directivesContainer.directives[i];\n          directive.type = \"ExpressionStatement\";\n          directive.expression = directive.value;\n          delete directive.value;\n          directive.expression.type = \"Literal\";\n          changeToLiteral(directive.expression, state);\n          body.unshift(directive);\n        }\n        delete directivesContainer.directives;\n      }\n    }\n\n    if (path.isJSXText()) {\n      node.type = \"Literal\";\n      node.raw = node.value;\n    }\n\n    if (path.isNumericLiteral() ||\n        path.isStringLiteral()) {\n      changeToLiteral(node, state);\n    }\n\n    if (path.isBooleanLiteral()) {\n      node.type = \"Literal\";\n      node.raw = String(node.value);\n    }\n\n    if (path.isNullLiteral()) {\n      node.type = \"Literal\";\n      node.raw = \"null\";\n      node.value = null;\n    }\n\n    if (path.isRegExpLiteral()) {\n      node.type = \"Literal\";\n      node.raw = node.extra.raw;\n      node.value = {};\n      node.regex = {\n        pattern: node.pattern,\n        flags: node.flags\n      };\n      delete node.extra;\n      delete node.pattern;\n      delete node.flags;\n    }\n\n    if (path.isObjectProperty()) {\n      node.type = \"Property\";\n      node.kind = \"init\";\n    }\n\n    if (path.isClassMethod() || path.isObjectMethod()) {\n      var code = state.source.slice(node.key.end, node.body.start);\n      var offset = code.indexOf(\"(\");\n\n      node.value = {\n        type: \"FunctionExpression\",\n        id: node.id,\n        params: node.params,\n        body: node.body,\n        async: node.async,\n        generator: node.generator,\n        expression: node.expression,\n        defaults: [], // basic support - TODO: remove (old esprima)\n        loc: {\n          start: {\n            line: node.key.loc.start.line,\n            column: node.key.loc.end.column + offset // a[() {]\n          },\n          end: node.body.loc.end\n        }\n      };\n      // [asdf]() {\n      node.value.range = [node.key.end + offset, node.body.end];\n\n      node.value.start = node.value.range && node.value.range[0] || node.value.loc.start.column;\n      node.value.end = node.value.range && node.value.range[1] || node.value.loc.end.column;\n\n      if (node.returnType) {\n        node.value.returnType = node.returnType;\n      }\n\n      if (node.typeParameters) {\n        node.value.typeParameters = node.typeParameters;\n      }\n\n      if (path.isClassMethod()) {\n        node.type = \"MethodDefinition\";\n      }\n\n      if (path.isObjectMethod()) {\n        node.type = \"Property\";\n        if (node.kind === \"method\") {\n          node.kind = \"init\";\n        }\n      }\n\n      delete node.body;\n      delete node.id;\n      delete node.async;\n      delete node.generator;\n      delete node.expression;\n      delete node.params;\n      delete node.returnType;\n      delete node.typeParameters;\n    }\n\n    if (path.isRestProperty() || path.isSpreadProperty()) {\n      node.type = `Experimental${node.type}`;\n    }\n\n    if (path.isTypeParameter && path.isTypeParameter()) {\n      node.type = \"Identifier\";\n      node.typeAnnotation = node.bound;\n      delete node.bound;\n    }\n\n    // flow: prevent \"no-undef\"\n    // for \"Component\" in: \"let x: React.Component\"\n    if (path.isQualifiedTypeIdentifier()) {\n      delete node.id;\n    }\n    // for \"b\" in: \"var a: { b: Foo }\"\n    if (path.isObjectTypeProperty()) {\n      delete node.key;\n    }\n    // for \"indexer\" in: \"var a: {[indexer: string]: number}\"\n    if (path.isObjectTypeIndexer()) {\n      delete node.id;\n    }\n    // for \"param\" in: \"var a: { func(param: Foo): Bar };\"\n    if (path.isFunctionTypeParam()) {\n      delete node.name;\n    }\n\n    // modules\n\n    if (path.isImportDeclaration()) {\n      delete node.isType;\n    }\n\n    if (path.isExportDeclaration()) {\n      var declar = path.get(\"declaration\");\n      if (declar.isClassExpression()) {\n        node.declaration.type = \"ClassDeclaration\";\n      } else if (declar.isFunctionExpression()) {\n        node.declaration.type = \"FunctionDeclaration\";\n      }\n    }\n\n    // TODO: remove (old esprima)\n    if (path.isFunction()) {\n      if (!node.defaults) {\n        node.defaults = [];\n      }\n    }\n\n    // template string range fixes\n    if (path.isTemplateLiteral()) {\n      for (var j = 0; j < node.quasis.length; j++) {\n        var q = node.quasis[j];\n        q.range[0] -= 1;\n        if (q.tail) {\n          q.range[1] += 1;\n        } else {\n          q.range[1] += 2;\n        }\n        q.loc.start.column -= 1;\n        if (q.tail) {\n          q.loc.end.column += 1;\n        } else {\n          q.loc.end.column += 2;\n        }\n      }\n    }\n  }\n};\n"}